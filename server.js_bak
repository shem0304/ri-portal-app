import fs from "fs";
import path from "path";
import crypto from "crypto";
import express from "express";
import cors from "cors";
import morgan from "morgan";
import compression from "compression";
import dotenv from "dotenv";
import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs";

dotenv.config();

const app = express();

// -----------------------------
// Config
// -----------------------------
const PORT = Number(process.env.PORT || 3000);
const JWT_SECRET = process.env.JWT_SECRET || "dev-secret-change-me";
const CLIENT_DIST = path.resolve("./client/dist");
const DATA_DIR = path.join(CLIENT_DIST, "data");

// -----------------------------
// Middleware
// -----------------------------
app.use(compression());
app.use(cors());
app.use(express.json({ limit: "2mb" }));
app.use(morgan(process.env.NODE_ENV === "development" ? "dev" : "combined"));

// -----------------------------
// Data loaders / caches
// -----------------------------
function readJson(filePath) {
  return JSON.parse(fs.readFileSync(filePath, "utf-8"));
}

const cache = new Map();
const cacheGet = (key) => cache.get(key);
const cacheSet = (key, value) => {
  // Simple cap to avoid runaway memory
  if (cache.size > 100) cache.clear();
  cache.set(key, value);
  return value;
};

// Reports are large; load once.
const LOCAL_REPORTS_PATH = path.join(DATA_DIR, "local_reports.json");
const NATIONAL_REPORTS_PATH = path.join(DATA_DIR, "national_reports.json");
const LOCAL_REPORTS = fs.existsSync(LOCAL_REPORTS_PATH) ? readJson(LOCAL_REPORTS_PATH) : [];
const NATIONAL_REPORTS = fs.existsSync(NATIONAL_REPORTS_PATH) ? readJson(NATIONAL_REPORTS_PATH) : [];

function getReportsByScope(scope) {
  if (scope === "local") return LOCAL_REPORTS;
  if (scope === "national") return NATIONAL_REPORTS;
  return LOCAL_REPORTS.concat(NATIONAL_REPORTS);
}

// -----------------------------
// Helpers
// -----------------------------
function normalizeStr(v) {
  return String(v || "").trim();
}

function safeInt(v, fallback) {
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
}

function titleText(r) {
  return normalizeStr(r.title || r.report_title || r.name || "");
}

function instituteName(r) {
  return normalizeStr(r.institute || r.institute_name || r.org || "");
}

function reportYear(r) {
  const y = r.year ?? r.publish_year ?? r.pub_year ?? r.report_year;
  const n = Number(y);
  return Number.isFinite(n) ? n : null;
}

function reportUrl(r) {
  return normalizeStr(r.url || r.link || r.href || "");
}

function matchesQuery(r, q) {
  if (!q) return true;
  const t = `${titleText(r)} ${instituteName(r)}`.toLowerCase();
  return t.includes(q.toLowerCase());
}

function filterReports(reports, { institute, year, q }) {
  const inst = normalizeStr(institute);
  const y = normalizeStr(year);
  const query = normalizeStr(q);

  return reports.filter((r) => {
    if (inst && instituteName(r) !== inst) return false;
    if (y) {
      const ry = reportYear(r);
      if (!ry || String(ry) !== y) return false;
    }
    if (!matchesQuery(r, query)) return false;
    return true;
  });
}

// A light tokenizer (title-based). This is intentionally simple so it works offline.
const STOP = new Set([
  "및",
  "등",
  "대한",
  "연구",
  "분석",
  "방안",
  "정책",
  "보고서",
  "사업",
  "활성화",
  "개선",
  "기반",
  "지역",
  "국가",
  "정부",
  "지자체",
  "협력",
  "지원",
  "현황",
  "사례",
  "조사",
  "전략",
  "계획",
  "발전",
  "효과",
  "평가",
  "추진",
  "체계",
  "모델",
  "제도",
  "운영",
  "관리",
  "활용",
  "혁신",
]);

function tokenizeTitle(t) {
  const s = normalizeStr(t)
    // keep Korean/English/numbers, split others
    .replace(/[^0-9A-Za-z\u3131-\uD79D]+/g, " ")
    .toLowerCase();
  const parts = s.split(/\s+/).filter(Boolean);
  return parts
    .map((p) => p.trim())
    .filter((p) => p.length >= 2)
    .filter((p) => !STOP.has(p));
}

function keywordCounts(reports) {
  const m = new Map();
  for (const r of reports) {
    const toks = tokenizeTitle(titleText(r));
    for (const w of toks) m.set(w, (m.get(w) || 0) + 1);
  }
  return m;
}

// -----------------------------
// Auth
// -----------------------------
const USERS_PATH = path.join(DATA_DIR, "users.json");
function readUsers() {
  if (!fs.existsSync(USERS_PATH)) return [];
  const v = readJson(USERS_PATH);
  return Array.isArray(v) ? v : [];
}

function writeUsers(users) {
  // Best-effort persistence. On some platforms (read-only FS) this will fail.
  try {
    fs.writeFileSync(USERS_PATH, JSON.stringify(users, null, 2), "utf-8");
    return true;
  } catch {
    return false;
  }
}

function signToken(user) {
  return jwt.sign({ sub: user.id, username: user.username }, JWT_SECRET, { expiresIn: "7d" });
}

function authRequired(req, res, next) {
  const header = req.headers.authorization || "";
  const [, token] = header.split(" ");
  if (!token) return res.status(401).json({ message: "Unauthorized" });
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    return next();
  } catch {
    return res.status(401).json({ message: "Invalid token" });
  }
}

app.post("/api/auth/login", async (req, res) => {
  const username = normalizeStr(req.body?.username);
  const password = normalizeStr(req.body?.password);
  if (!username || !password) return res.status(400).json({ message: "username/password required" });

  const users = readUsers();
  const user = users.find((u) => u.username === username);
  if (!user) return res.status(401).json({ message: "Invalid credentials" });

  const ok = await bcrypt.compare(password, user.password_hash);
  if (!ok) return res.status(401).json({ message: "Invalid credentials" });

  const token = signToken(user);
  return res.json({ token, user: { id: user.id, username: user.username, role: user.role || "user" } });
});

app.post("/api/auth/register", async (req, res) => {
  const username = normalizeStr(req.body?.username);
  const password = normalizeStr(req.body?.password);
  if (!username || !password) return res.status(400).json({ message: "username/password required" });

  const users = readUsers();
  if (users.some((u) => u.username === username)) return res.status(409).json({ message: "User exists" });

  const password_hash = await bcrypt.hash(password, 10);
  const user = { id: crypto.randomUUID(), username, password_hash, role: "user" };
  users.push(user);

  const persisted = writeUsers(users);
  const token = signToken(user);
  return res.status(persisted ? 201 : 201).json({
    token,
    user: { id: user.id, username: user.username, role: user.role },
    persisted,
    note: persisted ? undefined : "User created in-memory only (filesystem may be read-only on this host).",
  });
});

app.get("/api/auth/me", authRequired, (req, res) => {
  const users = readUsers();
  const user = users.find((u) => u.id === req.user?.sub);
  if (!user) return res.status(404).json({ message: "User not found" });
  return res.json({ user: { id: user.id, username: user.username, role: user.role || "user" } });
});

// -----------------------------
// Static data APIs
// -----------------------------
app.get("/api/institutes/local", (req, res) => {
  const p = path.join(DATA_DIR, "local_institutes.json");
  return res.json(fs.existsSync(p) ? readJson(p) : []);
});

app.get("/api/institutes/national", (req, res) => {
  const p = path.join(DATA_DIR, "national_institutes.json");
  return res.json(fs.existsSync(p) ? readJson(p) : { updated_at: null, sources: [], nst: [], nrc: [] });
});

app.get("/api/press/latest", (req, res) => {
  // The original build referenced a JSON file that isn't included in the upload.
  // Return an empty list so the UI can render safely.
  return res.json({ items: [] });
});

// -----------------------------
// Reports search
// -----------------------------
app.get("/api/reports/search", (req, res) => {
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);
  const limit = Math.min(200, Math.max(1, safeInt(req.query.limit, 50)));
  const offset = Math.max(0, safeInt(req.query.offset, 0));

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });
  const total = filtered.length;
  const page = filtered.slice(offset, offset + limit);
  const items = page.map((r, idx) => ({
    id: r.id || r.report_id || `${scope}-${offset + idx}`,
    year: reportYear(r) || "-",
    institute: instituteName(r) || "-",
    title: titleText(r) || "-",
    url: reportUrl(r) || "",
  }));

  return res.json({ items, total, limit, offset });
});

// -----------------------------
// Trends
// -----------------------------
app.get("/api/trends/summary", (req, res) => {
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const key = `summary:${scope}:${institute}:${year}:${q}`;
  const cached = cacheGet(key);
  if (cached) return res.json(cached);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });

  const byInst = new Map();
  const byYear = new Map();
  for (const r of filtered) {
    const inst = instituteName(r) || "-";
    byInst.set(inst, (byInst.get(inst) || 0) + 1);
    const yv = reportYear(r);
    if (yv) byYear.set(yv, (byYear.get(yv) || 0) + 1);
  }

  const reportsPerInstitute = [...byInst.entries()]
    .map(([k, v]) => ({ institute: k, count: v }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 500);
  const reportsPerYear = [...byYear.entries()]
    .map(([k, v]) => ({ year: Number(k), count: v }))
    .sort((a, b) => a.year - b.year);

  return res.json(
    cacheSet(key, {
      totalReports: filtered.length,
      reportsPerInstitute,
      reportsPerYear,
    })
  );
});

app.get("/api/trends/top5", (req, res) => {
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const key = `top5:${scope}:${institute}:${year}:${q}`;
  const cached = cacheGet(key);
  if (cached) return res.json(cached);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });

  // Count keywords overall, pick top 5
  const counts = keywordCounts(filtered);
  const top5 = [...counts.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([w]) => w);

  // Build year series per keyword
  const years = [...new Set(filtered.map(reportYear).filter(Boolean))].sort((a, b) => a - b);
  const series = top5.map((kw) => {
    const ymap = new Map(years.map((y) => [y, 0]));
    for (const r of filtered) {
      const y = reportYear(r);
      if (!y) continue;
      const toks = tokenizeTitle(titleText(r));
      if (toks.includes(kw)) ymap.set(y, (ymap.get(y) || 0) + 1);
    }
    return { keyword: kw, data: years.map((y) => ({ year: y, count: ymap.get(y) || 0 })) };
  });

  return res.json(cacheSet(key, { top5, series }));
});

app.get("/api/trends/keyword", (req, res) => {
  const keyword = normalizeStr(req.query.keyword);
  if (!keyword) return res.status(400).json({ message: "keyword required" });

  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const key = `kw:${keyword}:${scope}:${institute}:${year}:${q}`;
  const cached = cacheGet(key);
  if (cached) return res.json(cached);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });
  const byYear = new Map();
  for (const r of filtered) {
    const yv = reportYear(r);
    if (!yv) continue;
    const toks = tokenizeTitle(titleText(r));
    if (!toks.includes(keyword.toLowerCase())) continue;
    byYear.set(yv, (byYear.get(yv) || 0) + 1);
  }
  const data = [...byYear.entries()]
    .map(([y, c]) => ({ year: Number(y), count: c }))
    .sort((a, b) => a.year - b.year);

  return res.json(cacheSet(key, { keyword, data }));
});

app.get("/api/trends/wordcloud", (req, res) => {
  const top = Math.min(500, Math.max(1, safeInt(req.query.top, 50)));
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const key = `wc:${top}:${scope}:${institute}:${year}:${q}`;
  const cached = cacheGet(key);
  if (cached) return res.json(cached);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });
  const counts = keywordCounts(filtered);
  const items = [...counts.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, top)
    .map(([text, value]) => ({ text, value }));

  return res.json(cacheSet(key, { items }));
});

app.get("/api/trends/network", (req, res) => {
  const topKeywords = Math.min(300, Math.max(20, safeInt(req.query.topKeywords, 120)));
  const edgeTop = Math.min(2000, Math.max(50, safeInt(req.query.edgeTop, 400)));
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const key = `net:${topKeywords}:${edgeTop}:${scope}:${institute}:${year}:${q}`;
  const cached = cacheGet(key);
  if (cached) return res.json(cached);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });
  const counts = keywordCounts(filtered);

  const top = [...counts.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, topKeywords)
    .map(([w, c]) => ({ w, c }));
  const topSet = new Set(top.map((t) => t.w));

  const edgeMap = new Map();
  for (const r of filtered) {
    const toks = [...new Set(tokenizeTitle(titleText(r)).filter((t) => topSet.has(t)))];
    if (toks.length < 2) continue;
    toks.sort();
    for (let i = 0; i < toks.length; i++) {
      for (let j = i + 1; j < toks.length; j++) {
        const k = `${toks[i]}||${toks[j]}`;
        edgeMap.set(k, (edgeMap.get(k) || 0) + 1);
      }
    }
  }

  const edges = [...edgeMap.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, edgeTop)
    .map(([k, weight]) => {
      const [source, target] = k.split("||");
      return { source, target, weight };
    });
  const nodes = top.map(({ w, c }) => ({ id: w, size: c }));

  return res.json(cacheSet(key, { nodes, edges }));
});

app.get("/api/trends/heatmap", (req, res) => {
  const topKeywords = Math.min(80, Math.max(10, safeInt(req.query.topKeywords, 30)));
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const key = `hm:${topKeywords}:${scope}:${institute}:${year}:${q}`;
  const cached = cacheGet(key);
  if (cached) return res.json(cached);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });
  const counts = keywordCounts(filtered);
  const keywords = [...counts.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, topKeywords)
    .map(([w]) => w);
  const kwSet = new Set(keywords);

  const instTotals = new Map();
  const instKw = new Map(); // inst -> Map(kw -> count)
  for (const r of filtered) {
    const inst = instituteName(r) || "-";
    instTotals.set(inst, (instTotals.get(inst) || 0) + 1);
    const toks = tokenizeTitle(titleText(r));
    let m = instKw.get(inst);
    if (!m) {
      m = new Map();
      instKw.set(inst, m);
    }
    for (const t of toks) {
      if (!kwSet.has(t)) continue;
      m.set(t, (m.get(t) || 0) + 1);
    }
  }

  const rows = [...instTotals.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 120)
    .map(([inst, total]) => {
      const row = { institute: inst };
      const m = instKw.get(inst) || new Map();
      for (const kw of keywords) {
        const c = m.get(kw) || 0;
        row[kw] = total ? c / total : 0;
      }
      return row;
    });

  return res.json(cacheSet(key, { keywords, rows }));
});

app.get("/api/trends/related", authRequired, (req, res) => {
  const keyword = normalizeStr(req.query.keyword);
  if (!keyword) return res.status(400).json({ message: "keyword required" });

  const limit = Math.min(200, Math.max(1, safeInt(req.query.limit, 50)));
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });
  const kwLower = keyword.toLowerCase();
  const items = [];
  for (let i = 0; i < filtered.length && items.length < limit; i++) {
    const r = filtered[i];
    const toks = tokenizeTitle(titleText(r));
    if (!toks.includes(kwLower)) continue;
    items.push({
      id: r.id || r.report_id || `${scope}-${i}`,
      year: reportYear(r) || "-",
      institute: instituteName(r) || "-",
      title: titleText(r) || "-",
      url: reportUrl(r) || "",
    });
  }
  return res.json({ keyword, items });
});

app.get("/api/trends/rising", (req, res) => {
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });
  const years = [...new Set(filtered.map(reportYear).filter(Boolean))].sort((a, b) => a - b);
  const baseYear = years.at(-2) ?? years.at(-1) ?? null;
  const compareYear = years.at(-1) ?? null;
  if (!baseYear || !compareYear || baseYear === compareYear) return res.json({ baseYear, compareYear, items: [] });

  const baseReports = filtered.filter((r) => reportYear(r) === baseYear);
  const compareReports = filtered.filter((r) => reportYear(r) === compareYear);
  const baseCounts = keywordCounts(baseReports);
  const compareCounts = keywordCounts(compareReports);

  const allKeys = new Set([...baseCounts.keys(), ...compareCounts.keys()]);
  const items = [...allKeys]
    .map((k) => {
      const baseCount = baseCounts.get(k) || 0;
      const compareCount = compareCounts.get(k) || 0;
      const growth = (compareCount - baseCount) / Math.max(1, baseCount);
      return { keyword: k, baseCount, compareCount, growth };
    })
    .filter((x) => x.compareCount >= 2) // avoid noise
    .sort((a, b) => b.growth - a.growth)
    .slice(0, 20);

  return res.json({ baseYear, compareYear, items });
});

app.get("/api/trends/burst", (req, res) => {
  // Simple burst: z-score of last-year count vs historical mean/std.
  const scope = normalizeStr(req.query.scope) || "all";
  const institute = normalizeStr(req.query.institute);
  const year = normalizeStr(req.query.year);
  const q = normalizeStr(req.query.q);

  const base = getReportsByScope(scope);
  const filtered = filterReports(base, { institute, year, q });
  const years = [...new Set(filtered.map(reportYear).filter(Boolean))].sort((a, b) => a - b);
  const lastYear = years.at(-1);
  if (!lastYear) return res.json({ lastYear: null, items: [] });

  // Build per-year keyword counts for a moderate set of keywords
  const overall = keywordCounts(filtered);
  const topKeywords = [...overall.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 200)
    .map(([k]) => k);
  const kwSet = new Set(topKeywords);

  const perYear = new Map(); // year -> Map(kw->count)
  for (const y of years) perYear.set(y, new Map());
  for (const r of filtered) {
    const y = reportYear(r);
    if (!y) continue;
    const m = perYear.get(y);
    for (const t of tokenizeTitle(titleText(r))) {
      if (!kwSet.has(t)) continue;
      m.set(t, (m.get(t) || 0) + 1);
    }
  }

  const items = topKeywords
    .map((kw) => {
      const series = years.map((y) => perYear.get(y).get(kw) || 0);
      const lastVal = series.at(-1) || 0;
      const hist = series.slice(0, -1);
      const mean = hist.length ? hist.reduce((a, b) => a + b, 0) / hist.length : 0;
      const variance = hist.length
        ? hist.reduce((a, b) => a + (b - mean) * (b - mean), 0) / hist.length
        : 0;
      const std = Math.sqrt(variance) || 1;
      const z = (lastVal - mean) / std;
      return { keyword: kw, z, lastVal };
    })
    .filter((x) => x.lastVal >= 2)
    .sort((a, b) => b.z - a.z)
    .slice(0, 20);

  return res.json({ lastYear, items });
});

// -----------------------------
// Static hosting (SPA)
// -----------------------------
app.use(express.static(CLIENT_DIST));

// SPA fallback
app.get("*", (req, res) => {
  return res.sendFile(path.join(CLIENT_DIST, "index.html"));
});

app.listen(PORT, () => {
  console.log(`RI Portal server listening on http://localhost:${PORT}`);
});
